<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Frozen Christmas Nebula (Fixed)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Berkshire+Swash&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000510; color: white; font-family: sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* ---------------- å†°é›ªè‰ºæœ¯å­— ---------------- */
        #title-container {
            position: absolute; top: 8%; width: 100%; text-align: center; z-index: 10;
            pointer-events: none;
        }
        h1.ice-text {
            font-family: 'Berkshire Swash', cursive;
            font-size: 5rem;
            margin: 0;
            /* å†°å—è´¨æ„Ÿæ¸å˜ */
            background: linear-gradient(180deg, #ffffff 30%, #a5d6ff 60%, #0077be 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            /* å‘å…‰æ»¤é•œ */
            filter: drop-shadow(0 0 10px rgba(165, 214, 255, 0.9)) drop-shadow(0 0 20px rgba(0, 191, 255, 0.5));
            animation: floatText 4s ease-in-out infinite;
        }
        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        /* ---------------- UI ç•Œé¢ ---------------- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 5, 16, 0.6); /* åŠé€æ˜ï¼Œèƒ½çœ‹åˆ°åé¢çš„æ ‘ */
            z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; transition: opacity 0.8s;
            backdrop-filter: blur(3px);
        }
        #start-btn {
            border: 2px solid #a5d6ff; padding: 15px 40px; border-radius: 30px;
            background: rgba(0,0,0,0.5); color: #a5d6ff; font-size: 1.5rem;
            box-shadow: 0 0 15px #a5d6ff; transition: all 0.3s;
        }
        #start-btn:hover { background: #a5d6ff; color: #000; box-shadow: 0 0 30px #a5d6ff; }
        
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 5;
            width: 160px; height: 120px; border: 2px solid rgba(165, 214, 255, 0.5); 
            border-radius: 10px; overflow: hidden; transform: scaleX(-1);
            opacity: 0.7; display: none;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        .instructions {
            position: absolute; top: 20px; left: 20px; z-index: 5;
            background: rgba(0, 20, 40, 0.4); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(165, 214, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        .instructions h3 { margin: 0 0 10px 0; color: #a5d6ff; }
        .instructions p { font-size: 0.9rem; margin: 5px 0; color: #eee; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <audio id="bgm" loop preload="auto">
        <source src="audio.mp3" type="audio/mpeg">
    </audio>

    <div id="title-container">
        <h1 class="ice-text">Merry Christmas</h1>
    </div>

    <div id="start-screen">
        <div id="start-btn">ç‚¹å‡»æ’­æ”¾éŸ³ä¹ä¸äº¤äº’</div>
        <p style="color:#8af; margin-top:15px;">Turn on Sound & Magic</p>
    </div>

    <div class="instructions">
        <h3>Magic Control</h3>
        <p>ğŸ–ï¸ <b>Open Hand</b>: Explode (Nebula)</p>
        <p>ğŸ‘Š <b>Fist</b>: Assemble (Tree)</p>
        <p>ğŸ‘‹ <b>Move</b>: 3D Rotate</p>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

    <div id="canvas-container"></div>

<script>
// --- å…¨å±€é…ç½® ---
const CONFIG = {
    particleCount: 6000,
    ribbonCount: 800,
    snowCount: 1200,
    treeHeight: 75,
    treeRadius: 32,
    explosionRadius: 110,
    // çº¯å‡€å†°é›ªè‰²ç³»
    colors: [0xffffff, 0xa5d6ff, 0x00bfff, 0xe0ffff, 0xb0e0e6], 
    cameraZ: 130
};

const STATE = {
    isExploded: false,
    handDetected: false,
    targetRotationX: 0, 
    targetRotationY: 0,
    isMusicPlaying: false
};

let scene, camera, renderer, clock;
let particlesMesh, snowMesh, topStarMesh;
let particlesGeometry;
let mouse = new THREE.Vector2();
const particleData = []; 
let cameraReady = false;

// --- åˆå§‹åŒ–åœºæ™¯ ---
function initScene() {
    clock = new THREE.Clock();
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000510, 0.002); // é›¾æ°”

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, CONFIG.cameraZ);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000510, 1);
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    scene.add(new THREE.AmbientLight(0x666666));
    const pl = new THREE.PointLight(0xa5d6ff, 1.5, 300);
    pl.position.set(30, 60, 50);
    scene.add(pl);

    // --- å…³é”®ä¿®å¤ï¼šæ­£ç¡®ç”Ÿæˆçº¹ç† ---
    const pTex = createParticleTexture();
    const sTex = createStarTexture();

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    createCombinedSystem(pTex);

    // åˆ›å»ºæ˜Ÿæ˜Ÿ
    const starMat = new THREE.SpriteMaterial({ 
        map: sTex, color: 0xffffff, blending: THREE.AdditiveBlending, opacity: 0.95 
    });
    topStarMesh = new THREE.Sprite(starMat);
    topStarMesh.scale.set(16, 16, 1);
    topStarMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
    scene.add(topStarMesh);

    // åˆ›å»ºé£˜é›ª
    createSnowSystem(pTex);

    // äº‹ä»¶
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousemove', onMouseMove, false);
    document.addEventListener('click', onCanvasClick);
    
    // UIäº¤äº’
    const startScreen = document.getElementById('start-screen');
    const bgm = document.getElementById('bgm');
    bgm.volume = 0.5;

    startScreen.addEventListener('click', () => {
        if(!STATE.isMusicPlaying){
            STATE.isMusicPlaying = true;
            startScreen.style.opacity = 0;
            setTimeout(() => startScreen.style.display='none', 800);
            bgm.play().catch(e => console.log("Audio play failed", e));
            if(cameraReady) document.getElementById('video-container').style.display='block';
        }
    });

    animate();
}

// --- ç²’å­ç³»ç»Ÿé€»è¾‘ ---
function createCombinedSystem(texture) {
    particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const colorHelper = new THREE.Color();
    const totalParticles = CONFIG.particleCount + CONFIG.ribbonCount;

    // 1. æ ‘ä½“ç²’å­ (è¡¨é¢ + å†…éƒ¨å¡«å……)
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const sx = (Math.random()-0.5)*300;
        const sy = (Math.random()-0.5)*300;
        const sz = (Math.random()-0.5)*300;
        positions.push(sx, sy, sz);

        colorHelper.setHex(CONFIG.colors[Math.floor(Math.random()*CONFIG.colors.length)]);
        colors.push(colorHelper.r, colorHelper.g, colorHelper.b);

        const size = Math.random()*3 + 1.5;
        sizes.push(size);

        // è®¡ç®—æ ‘çš„ç›®æ ‡ä½ç½®
        const p = i / CONFIG.particleCount; 
        const isSurface = Math.random() > 0.35; // 65%åœ¨è¡¨é¢ï¼Œ35%åœ¨å†…éƒ¨
        const angle = p * Math.PI * 45 + i*0.01; 
        let radius = (1 - Math.pow(p, 1.2)) * CONFIG.treeRadius; 
        
        if (!isSurface) radius *= Math.sqrt(Math.random()); // å†…éƒ¨å¡«å……

        const tx = Math.cos(angle) * radius;
        const ty = p * CONFIG.treeHeight - CONFIG.treeHeight/2;
        const tz = Math.sin(angle) * radius;

        // æ˜Ÿäº‘ä½ç½®
        const nebula = calculateNebulaPos(i, totalParticles);

        particleData.push({
            type: 'tree',
            treePos: new THREE.Vector3(tx, ty, tz),
            nebulaPos: new THREE.Vector3(nebula.x, nebula.y, nebula.z),
            currentPos: new THREE.Vector3(sx, sy, sz),
            baseSize: size,
            isTwinkling: Math.random() < 0.3,
            twinkleOffset: Math.random() * 10,
            offset: Math.random() * 100
        });
    }

    // 2. å†°ä¸å¸¦ç²’å­
    for (let i = 0; i < CONFIG.ribbonCount; i++) {
        positions.push(0, -100, 0); // åˆå§‹è—åœ¨ä¸‹é¢
        colorHelper.setHex(0xd0f0ff); // äº®ç™½è“
        colors.push(colorHelper.r, colorHelper.g, colorHelper.b);
        sizes.push(Math.random()*2 + 3.5);

        const nebula = calculateNebulaPos(CONFIG.particleCount + i, totalParticles);

        particleData.push({
            type: 'ribbon',
            ribbonIndex: i, 
            nebulaPos: new THREE.Vector3(nebula.x, nebula.y, nebula.z),
            currentPos: new THREE.Vector3(0, -100, 0),
            baseSize: 4.0
        });
    }

    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    particlesGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const mat = new THREE.PointsMaterial({
        size: 4, vertexColors: true, map: texture, blending: THREE.AdditiveBlending,
        depthWrite: false, transparent: true, opacity: 0.9, sizeAttenuation: true
    });
    particlesMesh = new THREE.Points(particlesGeometry, mat);
    scene.add(particlesMesh);
}

function calculateNebulaPos(i, total) {
    const phi = Math.acos(1 - 2 * (i + 0.5) / total);
    const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
    const r = CONFIG.explosionRadius * (0.6 + Math.random()*0.5);
    return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
    };
}

function createSnowSystem(texture) {
    snowGeometry = new THREE.BufferGeometry();
    const pos = []; const vels = [];
    for(let i=0; i<CONFIG.snowCount; i++){
        pos.push((Math.random()-0.5)*250, Math.random()*200-100, (Math.random()-0.5)*250);
        vels.push((Math.random()-0.5)*0.2, -Math.random()*0.3-0.1, (Math.random()-0.5)*0.2);
    }
    snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    snowMesh = new THREE.Points(snowGeometry, new THREE.PointsMaterial({
        color: 0xffffff, size: 2.5, map: texture, transparent: true, opacity: 0.6,
        blending: THREE.AdditiveBlending, depthWrite: false
    }));
    snowMesh.userData = { vels: vels };
    scene.add(snowMesh);
}

// --- çº¹ç†ç”Ÿæˆ (ä¿®å¤ç‰ˆ) ---
function createParticleTexture() {
    const c = document.createElement('canvas'); c.width=32; c.height=32;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(16,16,0,16,16,16);
    g.addColorStop(0,'rgba(255,255,255,1)'); 
    g.addColorStop(0.4,'rgba(200,240,255,0.4)'); 
    g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
    
    // é‡è¦ä¿®å¤ï¼šè®¾ç½® needsUpdate
    const t = new THREE.Texture(c);
    t.needsUpdate = true; 
    return t;
}

function createStarTexture() {
    const c = document.createElement('canvas'); c.width=64; c.height=64;
    const ctx = c.getContext('2d');
    ctx.shadowBlur=20; ctx.shadowColor="#a5d6ff"; ctx.fillStyle="#fff";
    ctx.beginPath();
    for(let i=0; i<8; i++){
        const a = i*Math.PI/4; const r = i%2===0?28:10;
        ctx.lineTo(32+r*Math.cos(a), 32+r*Math.sin(a));
    }
    ctx.fill();
    const g=ctx.createRadialGradient(32,32,2,32,32,22);
    g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(165,214,255,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(32,32,22,0,Math.PI*2); ctx.fill();
    
    const t = new THREE.Texture(c);
    t.needsUpdate = true;
    return t;
}

// --- åŠ¨ç”»ä¸»å¾ªç¯ ---
function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    const positions = particlesGeometry.attributes.position.array;
    const sizes = particlesGeometry.attributes.size.array;

    for (let i = 0; i < particleData.length; i++) {
        const data = particleData[i];
        let tx, ty, tz;

        if (STATE.isExploded) {
            tx = data.nebulaPos.x; ty = data.nebulaPos.y; tz = data.nebulaPos.z;
        } else {
            if (data.type === 'tree') {
                tx = data.treePos.x + Math.sin(time + data.offset) * 0.5;
                ty = data.treePos.y + Math.cos(time + data.offset) * 0.5;
                tz = data.treePos.z + Math.sin(time*0.5 + data.offset) * 0.5;
                
                // æ ‘é—ªçƒ
                if (data.isTwinkling) sizes[i] = data.baseSize * (0.6 + (Math.sin(time*3+data.twinkleOffset)*0.5+0.5));
                
            } else if (data.type === 'ribbon') {
                // ä¸å¸¦èºæ—‹ä¸Šå‡ç®—æ³•
                const ribbonSpeed = 10.0;
                const loopH = CONFIG.treeHeight + 30;
                let currentY = ((data.ribbonIndex * 0.1) + (time * ribbonSpeed)) % loopH;
                currentY -= loopH / 2;
                
                const p = (currentY + loopH/2) / loopH; 
                // é˜²æ­¢ p è¶…å‡ºèŒƒå›´
                const safeP = Math.max(0, Math.min(1, p));
                
                const r = (1 - Math.pow(safeP, 1.5)) * (CONFIG.treeRadius + 6);
                const rot = currentY * 0.25 - time * 2.0;

                tx = Math.cos(rot) * r;
                ty = currentY;
                tz = Math.sin(rot) * r;
                
                sizes[i] = data.baseSize * (0.8 + Math.sin(time*10+i)*0.3);
            }
        }

        const lerpFactor = STATE.isExploded ? 0.04 : 0.08;
        data.currentPos.x += (tx - data.currentPos.x) * lerpFactor;
        data.currentPos.y += (ty - data.currentPos.y) * lerpFactor;
        data.currentPos.z += (tz - data.currentPos.z) * lerpFactor;

        positions[i*3] = data.currentPos.x;
        positions[i*3+1] = data.currentPos.y;
        positions[i*3+2] = data.currentPos.z;
    }
    
    particlesGeometry.attributes.position.needsUpdate = true;
    particlesGeometry.attributes.size.needsUpdate = true;

    // æ˜Ÿæ˜ŸåŠ¨ç”»
    if(STATE.isExploded){
        topStarMesh.scale.lerp(new THREE.Vector3(0.1,0.1,0.1), 0.1);
        topStarMesh.material.opacity = 0;
    } else {
        topStarMesh.scale.setScalar(16 + Math.sin(time*3)*3);
        topStarMesh.material.opacity = 0.95;
        topStarMesh.position.y = CONFIG.treeHeight/2 + 2 + Math.sin(time)*1;
    }

    // é›ªèŠ±åŠ¨ç”»
    snowMesh.rotation.y = time * 0.03;
    const sp = snowMesh.geometry.attributes.position.array;
    const sv = snowMesh.userData.vels;
    for(let i=0; i<CONFIG.snowCount; i++){
        let iy = i*3+1;
        sp[iy] += sv[i*3+1] * (STATE.isExploded?0.2:1);
        sp[i*3] += sv[i*3]; sp[i*3+2] += sv[i*3+2];
        if(sp[iy] < -100) {
            sp[iy]=100; sp[i*3]=(Math.random()-0.5)*250; sp[i*3+2]=(Math.random()-0.5)*250;
        }
    }
    snowMesh.geometry.attributes.position.needsUpdate = true;

    // æ—‹è½¬æ§åˆ¶
    const tx = STATE.handDetected ? STATE.targetRotationX : mouse.y * 0.6;
    const ty = STATE.handDetected ? STATE.targetRotationY : mouse.x * 1.2;
    scene.rotation.x += (tx - scene.rotation.x) * 0.05;
    scene.rotation.y += (ty - scene.rotation.y) * 0.05;

    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
function onMouseMove(e) {
    if(!STATE.handDetected && STATE.isMusicPlaying){
        mouse.x = (e.clientX/window.innerWidth)*2-1;
        mouse.y = (e.clientY/window.innerHeight)*2-1;
    }
}
function onCanvasClick(e) {
    // åªæœ‰åœ¨éŸ³ä¹æ’­æ”¾çŠ¶æ€ä¸‹ï¼ˆå·²å¯åŠ¨ï¼‰ç‚¹å‡»æ‰åˆ‡æ¢å½¢æ€
    if(!STATE.handDetected && STATE.isMusicPlaying && e.target.id !== 'start-screen' && e.target.id !== 'start-btn'){
        STATE.isExploded = !STATE.isExploded;
    }
}

// --- æ‰‹åŠ¿è¯†åˆ« ---
const videoElement = document.querySelector('.input_video');
let lastFist = false;

function onResults(results) {
    if(!STATE.isMusicPlaying) return;
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const lm = results.multiHandLandmarks[0];
        const dist = Math.sqrt(Math.pow(lm[12].x-lm[0].x,2) + Math.pow(lm[12].y-lm[0].y,2));
        const isFist = dist < 0.25;
        if(isFist !== lastFist) { STATE.isExploded = !isFist; lastFist = isFist; }
        
        STATE.targetRotationX = (lm[9].y - 0.5) * 2.5;
        STATE.targetRotationY = (1 - lm[9].x - 0.5) * 3.5;
    } else {
        STATE.handDetected = false;
    }
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
hands.onResults(onResults);

const cam = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 480, height: 360
});

// å¯åŠ¨
initScene();
cam.start().then(()=>{ cameraReady=true; }).catch(e=>console.log("Camera not allowed"));

</script>
</body>
</html>