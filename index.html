<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Ice & Snow Nebula Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* å¯åŠ¨é®ç½©å±‚ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; cursor: pointer; transition: opacity 0.5s;
        }
        #start-screen h1 { color: #a5d6ff; text-shadow: 0 0 20px #a5d6ff; margin-bottom: 10px; }
        #start-screen p { font-size: 1.2em; color: #ddd; }
        #loading-text { font-size: 0.9em; color: #888; margin-top: 20px; font-style: italic; }

        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 5;
            width: 160px; height: 120px; border: 2px solid rgba(165, 214, 255, 0.5); border-radius: 10px; overflow: hidden;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
            opacity: 0.7; display: none; /* åˆå§‹éšè—ï¼Œæ‘„åƒå¤´å‡†å¤‡å¥½å†æ˜¾ç¤º */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        .instructions {
            position: absolute; top: 20px; left: 20px; z-index: 5;
            background: rgba(0, 20, 40, 0.6); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(165, 214, 255, 0.3);
        }
        .instructions h3 { margin: 0 0 10px 0; color: #a5d6ff; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <audio id="bgm" loop preload="auto">
        <source src="audio.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div id="start-screen">
        <h1>ğŸ§Š å†°é›ªæ˜Ÿäº‘åœ£è¯æ ‘ ğŸ§Š</h1>
        <p>ç‚¹å‡»å±å¹•å¼€å¯ä½“éªŒå¹¶æ’­æ”¾éŸ³ä¹</p>
        <p id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹ä¸ 3D å¼•æ“...</p>
    </div>

    <div class="instructions">
        <h3>äº¤äº’æŒ‡å—</h3>
        <p>ğŸ–±ï¸ <b>é¼ æ ‡/æ‰‹åŠ¿ç§»åŠ¨</b>: å…¨æ–¹ä½æ—‹è½¬è§†è§’</p>
        <p>ğŸ–ï¸ <b>å¼ å¼€æ‰‹æŒ / ç‚¹å‡»</b>: çˆ†ç‚¸ (æ˜Ÿäº‘å½¢æ€)</p>
        <p>ğŸ‘Š <b>æ¡æ‹³ / ç‚¹å‡»</b>: é‡ç»„ (åœ£è¯æ ‘å½¢æ€)</p>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

    <div id="canvas-container"></div>

<script>
// --- é…ç½®ä¸çŠ¶æ€ ---
const CONFIG = {
    particleCount: 5000, // å¢åŠ ç²’å­æ•°é‡ä»¥è·å¾—æ›´å……å®çš„æ•ˆæœ
    snowCount: 800,
    treeHeight: 65,
    treeRadius: 28,
    explosionRadius: 90,
    // å†°é›ªä¸»é¢˜é…è‰²ï¼šçº¯ç™½ï¼Œå†°è“ï¼Œæ·±å¤©è“ï¼Œæ·¡é’ï¼Œäº®ç´«
    colors: [0xffffff, 0xa5d6ff, 0x00bfff, 0xe0ffff, 0xccccff], 
    cameraZ: 110
};

const STATE = {
    isExploded: false,
    handDetected: false,
    targetRotationX: 0, // ç›®æ ‡ä¿¯ä»°è§’ (ç»•Xè½´)
    targetRotationY: 0, // ç›®æ ‡åèˆªè§’ (ç»•Yè½´)
    isStarted: false    // æ˜¯å¦å·²ç‚¹å‡»å¼€å§‹
};

// å…¨å±€å˜é‡
let scene, camera, renderer, clock;
let particlesMesh, snowMesh, topStarMesh;
let particlesGeometry;
let mouse = new THREE.Vector2();
const particleData = []; // å­˜å‚¨ç²’å­æ•°æ®
let cameraReady = false;

// éŸ³é¢‘å…ƒç´ 
const bgm = document.getElementById('bgm');
bgm.volume = 0.4; // è®¾ç½®éŸ³é‡

// --- æ ¸å¿ƒåŠŸèƒ½å®ç° ---

function initScene() {
    clock = new THREE.Clock();
    const container = document.getElementById('canvas-container');
    
    // åœºæ™¯ä¸è¿·é›¾ (æ·±è“è‰²è¿·é›¾å¢å¼ºå†°å†·æ„Ÿ)
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000510, 0.0025);

    // æ‘„åƒæœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, CONFIG.cameraZ);
    camera.lookAt(0, 5, 0);

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000510, 1); // æ·±é‚ƒçš„å¤œç©ºèƒŒæ™¯è‰²
    container.appendChild(renderer.domElement);

    // å…‰ç…§ (ä¸ºäº†è®©æ˜Ÿæ˜Ÿæè´¨æ›´å¥½çœ‹)
    const ambientLight = new THREE.AmbientLight(0x444444);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xa5d6ff, 1, 200);
    pointLight.position.set(20, 50, 20);
    scene.add(pointLight);

    // çº¹ç†
    const particleTexture = createParticleTexture();
    const starTexture = createStarTexture();

    // --- 1. åˆ›å»ºä¸»ç²’å­ç³»ç»Ÿ (æ ‘/æ˜Ÿäº‘) ---
    createParticleSystem(particleTexture);

    // --- 2. åˆ›å»ºé¡¶éƒ¨å†°æ™¶æ˜Ÿæ˜Ÿ ---
    const starMaterial = new THREE.SpriteMaterial({ 
        map: starTexture, 
        color: 0xffffff, // çº¯ç™½å…‰èŠ’
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.9
    });
    topStarMesh = new THREE.Sprite(starMaterial);
    topStarMesh.scale.set(12, 12, 1);
    topStarMesh.position.set(0, CONFIG.treeHeight / 2 + 1, 0);
    scene.add(topStarMesh);

    // --- 3. åˆ›å»ºé£˜é›ª ---
    createSnowSystem(particleTexture);

    // äº‹ä»¶ç›‘å¬
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousemove', onMouseMove, false);
    
    // ç‚¹å‡»å¼€å§‹å¤„ç†
    const startScreen = document.getElementById('start-screen');
    startScreen.addEventListener('click', () => {
        if (!STATE.isStarted) {
            STATE.isStarted = true;
            startScreen.style.opacity = 0;
            setTimeout(() => { startScreen.style.display = 'none'; }, 500);
            // æ’­æ”¾éŸ³ä¹
            bgm.play().catch(e => console.log("Playback failed:", e));
            // å¦‚æœæ‘„åƒå¤´å‡†å¤‡å¥½äº†ï¼Œæ˜¾ç¤ºæ‘„åƒå¤´
            if (cameraReady) document.getElementById('video-container').style.display = 'block';
            // ç»‘å®šç‚¹å‡»åˆ‡æ¢äº‹ä»¶ (åœ¨å¼€å§‹åæ‰ç”Ÿæ•ˆ)
            document.addEventListener('click', onCanvasClick);
        }
    });

    animate();
}

function createParticleSystem(texture) {
    particlesGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const colorHelper = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åˆå§‹æ•£è½ä½ç½®
        const x = (Math.random() - 0.5) * 300;
        const y = (Math.random() - 0.5) * 300;
        const z = (Math.random() - 0.5) * 300;
        positions.push(x, y, z);

        // éšæœºå†°é›ªé¢œè‰²
        colorHelper.setHex(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
        colors.push(colorHelper.r, colorHelper.g, colorHelper.b);

        // åŸºç¡€å¤§å°
        const baseSize = Math.random() * 3.0 + 1.5;
        sizes.push(baseSize);

        // --- è®¡ç®—ç›®æ ‡ä½ç½® ---
        // åœ£è¯æ ‘å½¢æ€ (èºæ—‹é”¥)
        const p = i / CONFIG.particleCount; 
        const angle = p * Math.PI * 36 + i * 0.01; // å¢åŠ ä¸€äº›éšæœºè§’åº¦åç§»ï¼Œä½¿æ ‘æ›´è‡ªç„¶
        const radius = (1 - Math.pow(p, 1.5)) * CONFIG.treeRadius; // ä½¿ç”¨æŒ‡æ•°ä½¿é¡¶éƒ¨æ›´å°–
        const treeX = Math.cos(angle) * radius + (Math.random()-0.5)*1.5;
        const treeY = p * CONFIG.treeHeight - CONFIG.treeHeight / 2;
        const treeZ = Math.sin(angle) * radius + (Math.random()-0.5)*1.5;

        // æ˜Ÿäº‘å½¢æ€ (æ–æ³¢é‚£å¥‘çƒä½“åˆ†å¸ƒï¼Œæ›´å‡åŒ€)
        const phi = Math.acos(1 - 2 * (i + 0.5) / CONFIG.particleCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
        const nebulaRadius = CONFIG.explosionRadius * (0.6 + Math.random() * 0.6); // åŠå¾„æœ‰ä¸€å®šéšæœºèŒƒå›´
        const nebulaX = nebulaRadius * Math.sin(phi) * Math.cos(theta);
        const nebulaY = nebulaRadius * Math.sin(phi) * Math.sin(theta);
        const nebulaZ = nebulaRadius * Math.cos(phi);

        // é—ªçƒå±æ€§
        const isTwinkling = Math.random() < 0.25; // 25% çš„ç²’å­ä¼šé—ªçƒ

        particleData.push({
            treePos: new THREE.Vector3(treeX, treeY, treeZ),
            nebulaPos: new THREE.Vector3(nebulaX, nebulaY, nebulaZ),
            currentPos: new THREE.Vector3(x, y, z),
            baseSize: baseSize,
            isTwinkling: isTwinkling,
            twinkleSpeed: Math.random() * 3 + 2,
            twinkleOffset: Math.random() * Math.PI * 2,
            randomOffset: Math.random() * 100 // ç”¨äºå‘¼å¸åŠ¨ç”»çš„ç›¸ä½å·®
        });
    }

    particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    particlesGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const material = new THREE.PointsMaterial({
        size: 4, vertexColors: true, map: texture, blending: THREE.AdditiveBlending,
        depthWrite: false, transparent: true, opacity: 0.85, sizeAttenuation: true
    });
    particlesMesh = new THREE.Points(particlesGeometry, material);
    scene.add(particlesMesh);
}

function createSnowSystem(texture) {
    snowGeometry = new THREE.BufferGeometry();
    const positions = [];
    const vels = [];
    for (let i = 0; i < CONFIG.snowCount; i++) {
        positions.push((Math.random()-0.5)*250, Math.random()*200-100, (Math.random()-0.5)*250);
        vels.push((Math.random()-0.5)*0.1, -Math.random()*0.2-0.05, (Math.random()-0.5)*0.1);
    }
    snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    snowMesh = new THREE.Points(snowGeometry, new THREE.PointsMaterial({
        color: 0xffffff, size: 2, map: texture, transparent: true, opacity: 0.5,
        blending: THREE.AdditiveBlending, depthWrite: false
    }));
    snowMesh.userData = { vels: vels };
    scene.add(snowMesh);
}

// --- çº¹ç†ç”Ÿæˆå‡½æ•° (ä¿æŒä¸å˜ï¼Œé¢œè‰²å·²é€šè¿‡æè´¨è°ƒæ•´) ---
function createParticleTexture() {
    const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
    const ctx = canvas.getContext('2d');
    const g = ctx.createRadialGradient(16,16,0,16,16,16);
    g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(0.4,'rgba(200,230,255,0.4)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
    const t = new THREE.Texture(canvas); t.needsUpdate = true; return t;
}

function createStarTexture() {
    const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
    const ctx = canvas.getContext('2d');
    ctx.shadowBlur=15; ctx.shadowColor="#a5d6ff"; ctx.fillStyle="#ffffff";
    ctx.beginPath();
    // ç”»ä¸€ä¸ªæ›´å°–é”çš„å†°æ™¶æ˜Ÿå½¢
    for(let i=0; i<8; i++) {
        const angle = i * Math.PI / 4;
        const r = i%2===0 ? 30 : 10;
        ctx.lineTo(32 + r*Math.cos(angle), 32 + r*Math.sin(angle));
    }
    ctx.fill();
    const g = ctx.createRadialGradient(32,32,2,32,32,20);
    g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(165,214,255,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(32,32,20,0,Math.PI*2); ctx.fill();
    const t = new THREE.Texture(canvas); t.needsUpdate = true; return t;
}

// --- åŠ¨ç”»ä¸»å¾ªç¯ ---
function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    
    // 1. æ›´æ–°ä¸»ç²’å­
    const posAttr = particlesGeometry.attributes.position;
    const sizeAttr = particlesGeometry.attributes.size;
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const data = particleData[i];
        const target = STATE.isExploded ? data.nebulaPos : data.treePos;

        // å‘¼å¸æµ®åŠ¨
        const floatScale = STATE.isExploded ? 1.8 : 0.4;
        const fx = Math.sin(time + data.randomOffset) * floatScale;
        const fy = Math.cos(time * 1.2 + data.randomOffset) * floatScale;
        const fz = Math.sin(time * 0.8 + data.randomOffset) * floatScale;

        // ä½ç½®æ’å€¼ç§»åŠ¨
        data.currentPos.lerp(new THREE.Vector3(target.x+fx, target.y+fy, target.z+fz), 0.04);
        posAttr.setXYZ(i, data.currentPos.x, data.currentPos.y, data.currentPos.z);

        // é—ªçƒè®¡ç®—
        if (data.isTwinkling) {
            const twinkleFactor = Math.sin(time * data.twinkleSpeed + data.twinkleOffset) * 0.5 + 0.5; // 0~1
            // å¤§å°åœ¨ åŸºç¡€å¤§å° çš„ 50% åˆ° 150% ä¹‹é—´æ³¢åŠ¨
            sizeAttr.setX(i, data.baseSize * (0.5 + twinkleFactor));
        }
    }
    posAttr.needsUpdate = true;
    sizeAttr.needsUpdate = true;

    // 2. æ›´æ–°æ˜Ÿæ˜Ÿ
    if (!STATE.isExploded) {
        topStarMesh.position.y = CONFIG.treeHeight / 2 + 1 + Math.sin(time * 1.5) * 0.8;
        topStarMesh.scale.setScalar(12 + Math.sin(time * 4) * 2);
        topStarMesh.material.opacity += (1 - topStarMesh.material.opacity) * 0.1;
    } else {
        topStarMesh.scale.setScalar(0.1); // çˆ†ç‚¸æ—¶ç¼©å°ä¸å¯è§
        topStarMesh.material.opacity += (0 - topStarMesh.material.opacity) * 0.1;
    }

    // 3. æ›´æ–°é›ªèŠ± (åŠ å…¥ç®€å•çš„æ—‹è½¬)
    const snowPos = snowMesh.geometry.attributes.position.array;
    const snowVels = snowMesh.userData.vels;
    snowMesh.rotation.y = time * 0.05; // æ•´ä¸ªé›ªèŠ±å±‚ç¼“æ…¢æ—‹è½¬
    for (let i = 0; i < CONFIG.snowCount; i++) {
        let iy = i*3+1;
        snowPos[iy] += snowVels[i*3+1] * (STATE.isExploded ? 0.2 : 1); // çˆ†ç‚¸æ—¶ä¸‹é›ªå˜æ…¢
        snowPos[i*3] += snowVels[i*3]; snowPos[i*3+2] += snowVels[i*3+2];
        if (snowPos[iy] < -100) {
            snowPos[iy] = 100; 
            snowPos[i*3] = (Math.random()-0.5)*250; snowPos[i*3+2] = (Math.random()-0.5)*250;
        }
    }
    snowMesh.geometry.attributes.position.needsUpdate = true;

    // 4. å…¨æ–¹ä½æ—‹è½¬æ§åˆ¶ (æ ¸å¿ƒæ›´æ–°)
    // å¦‚æœæœ‰æ‰‹åŠ¿ï¼Œä¼˜å…ˆä½¿ç”¨æ‰‹åŠ¿ç›®æ ‡ï¼›å¦åˆ™ä½¿ç”¨é¼ æ ‡ç›®æ ‡
    const targetX = STATE.handDetected ? STATE.targetRotationX : (mouse.y * 0.8); // é™åˆ¶ä¸€ä¸‹ä»°è§’å¹…åº¦
    const targetY = STATE.handDetected ? STATE.targetRotationY : (mouse.x * 1.5);

    // ä½¿ç”¨ lerp å¹³æ»‘è¿‡æ¸¡æ—‹è½¬è§’åº¦
    scene.rotation.x += (targetX - scene.rotation.x) * 0.05;
    scene.rotation.y += (targetY - scene.rotation.y) * 0.05;

    renderer.render(scene, camera);
}

// --- äº¤äº’äº‹ä»¶ ---
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onMouseMove(event) {
    if (!STATE.handDetected && STATE.isStarted) {
        // å½’ä¸€åŒ–é¼ æ ‡ä½ç½® (-1 åˆ° 1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = (event.clientY / window.innerHeight) * 2 - 1; // yå‘ä¸‹ä¸ºæ­£
    }
}

function onCanvasClick(event) {
    // ç‚¹å‡»ç”»å¸ƒåˆ‡æ¢çŠ¶æ€ï¼ˆå¦‚æœæœªæ£€æµ‹åˆ°æ‰‹ï¼‰
    if (!STATE.handDetected && STATE.isStarted && event.target.tagName !== 'A') {
        STATE.isExploded = !STATE.isExploded;
    }
}

// --- AI æ‰‹åŠ¿è¯†åˆ« ---
const videoElement = document.getElementsByClassName('input_video')[0];
let lastFistState = false; // ç”¨äºå»æŠ–åŠ¨

function onResults(results) {
    const loadingText = document.getElementById('loading-text');
    if (loadingText && !cameraReady) {
        loadingText.textContent = "AI å°±ç»ªï¼è¯·ç‚¹å‡»å±å¹•å¼€å§‹ã€‚";
        cameraReady = true;
    }

    if (!STATE.isStarted) return; // è¿˜æ²¡å¼€å§‹å°±ä¸å¤„ç†æ‰‹åŠ¿

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        const wrist = landmarks[0];
        const midTip = landmarks[12];
        
        // 1. æ¡æ‹³æ£€æµ‹ (ç®€å•è·ç¦»åˆ¤æ–­)
        const dist = Math.sqrt(Math.pow(midTip.x-wrist.x, 2) + Math.pow(midTip.y-wrist.y, 2));
        const isFist = dist < 0.3;

        // ç®€å•çš„çŠ¶æ€å»æŠ–ï¼Œé˜²æ­¢ä¸´ç•Œç‚¹é—ªçƒ
        if (isFist !== lastFistState) {
             STATE.isExploded = !isFist;
             lastFistState = isFist;
        }

        // 2. å…¨æ–¹ä½æ—‹è½¬æ˜ å°„ (åŸºäºæ‰‹æŒä¸­å¿ƒç‚¹ 9)
        // Xè½´æ—‹è½¬ (ä¿¯ä»°): æ‰‹å‘ä¸Šç§»(yå˜å°) -> åœºæ™¯å‘ä¸Šä»°(rotXå˜è´Ÿ)
        STATE.targetRotationX = (landmarks[9].y - 0.5) * 2.5;
        // Yè½´æ—‹è½¬ (åèˆª): é•œåƒåï¼Œæ‰‹å‘å³ç§»(xå˜å¤§) -> åœºæ™¯å‘å³è½¬(rotYå˜å¤§)
        STATE.targetRotationY = (1 - landmarks[9].x - 0.5) * 4.0;

    } else {
        STATE.handDetected = false;
    }
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const cameraObj = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 480, height: 360 // é™ä½ä¸€ç‚¹åˆ†è¾¨ç‡æé«˜æ€§èƒ½
});

initScene();
cameraObj.start().catch(err => {
    console.warn("Camera error:", err);
    document.getElementById('loading-text').textContent = "æ‘„åƒå¤´å¯ç”¨å¤±è´¥ï¼Œè¯·ä½¿ç”¨é¼ æ ‡äº¤äº’ã€‚ç‚¹å‡»å±å¹•å¼€å§‹ã€‚";
});

</script>
</body>
</html>